{"./":{"url":"./","title":"前端","keywords":"","body":" 我的web前端学习成长之路. Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 16:52:32 "},"content/Linux/1-linux.html":{"url":"content/Linux/1-linux.html","title":"第一节：Linux 命令行","keywords":"","body":"Linux 系统有多种发行版 我们安装的是 深度 Linux ，这个系统跟国外的 Ubuntu Linux 非常类似。如果装不了深度，可以尝试安装 Ubuntu 。 其他的知名 Linux 发行版还有很多，例如 Red Hat ，Suse，Fedora , CentOS 等等。 打开命令行界面 Bash 简介 命令行能干什么？ 打开命令行界面 学习 linux 最重要的就是来使用它的命令行。 Ctrl-Alt-T 是深度 Linux 系统上打开命令行窗口的快捷键。这个命令行窗口程序，在 Mac 系统上叫 iTerm ，在深度系统上叫“深度终端”。 命令行窗口中可以运行的程序不唯一。默认启动的程序叫做 Bash ，这个是我们这个要学习的核心。在 Bash 下就可以来输入各种 Linux 命令了。例如，可以敲 ls 来列出当前位置都有哪些文件。 但是，命令行窗口中也能启动其他的程序，例如 Python/Javascript 的解析器。这些我们不管，所谓 学习 Linux 命令行，其实就是学习 Bash （ Mac 系统上用的命令行也是 Bash）。 Bash 简介 Bash 是各种命令行中最流行的一种，其中后两个字符 sh 是 shell 这个单词的缩写，shell 的意思就是“命令行”，前面 Ba 是人名，我们不用管。 Bash 的常用命令： ls 列出当前位置所有文件 rm 删除文件，或者文件夹 cd 改变当前位置 mv 移动文件 等等等等 命令行能干什么？ 命令行和鼠标（图形化的界面）一样是人类操作电脑的一种方式。基本上鼠标能干得活，命令行都能干（个别的像 Photoshop 的大部分操作，还是鼠标好用一些）。 同时，只要命令行能干的事情，都会比鼠标更高效，因为命令行是可以批处理的。实际开发中，我们用命令行最经常的操作就是，创建文件，删除移动文件等。 举个例子，如果我要在桌面上创建一个文件夹，可以用鼠标右键来创建，同时如果用命令行，操作如下 cd Desktop mkdir FolderName 上面 cd Desktop 改变当前位置到桌面。 mkdir 是创建一个文件夹的命令 最终操作结果是等价的。但是如果要学习命令行操作，第一步就是要掌握文件系统结构。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:14:32 "},"content/Linux/2-file-sys.html":{"url":"content/Linux/2-file-sys.html","title":"第二节：文件系统结构","keywords":"","body":"文件系统（ File System ） 如果我们想对文件进行，增删改查（ touch rm mv vim ），或者说进行文件的创建，删除，移动，重命名等操作，首先要解决是什么呢？要能找到它。或者说，就是要知道文件在文件系统上的位置。 所以，我们首先要说的是文件系统的结构。实际上就是说一下，Linux 系统默认的那些文件夹的结构。实际上这个结构是非常简单的。 Windows 系统上还分 C/D 盘，Linux 这里其实更简单。所有的文件夹都会存在一个顶级老祖宗文件夹之内。这个老祖宗的名字叫做 / 。 Linux 文件系统结构，就是老祖宗文件夹里面包含子文件夹或者文件，子文件里面又包含孙子辈的文件夹或者文件。这个文件系统其实就是一根倒挂的树，最顶端就是 / 这个文件夹。 用户主目录（ HOME ） 如何在文件系统内做跳转？ 使用绝对路径进行跳转 Tab 补齐 总结 用户主目录（ HOME ） 除了 / 这个文件夹之外，位置非常独特的文件夹还有一个，就是 /home/Liu ，它通常被称为用户主目录 （ Unix 传统下把文件夹就叫目录），它还有个外号叫 ~ 。用户登陆进系统之后，默认的着陆位置就是这个文件夹。同时，默认情况下，用户只是在这个文件夹里有写权限，而在这个之外的地方是没有写权限的。 要真正找到文件，需要我们学会如何在文件系统内做跳转 。 如何在文件系统内做跳转？ 这里我们会使用到的一个核心命令叫 cd （ Change Directory 改变文件夹 ) 。所以说文件系统内做跳转，其实就是改变当前文件夹。 查看当然文件夹中的内容，就用 ls 这个命令。我们可以看到的输出结果大概是 $ ls Desktop Application Download 那么，现在如果我们想要跳转到桌面（或者说就是把当然文件夹改变为桌面），那就来执行 cd Desktop 这样就可以跳转到桌面了。到桌面执行 mkdir FolderName 来看看这个新的文件夹，是否真正创建到了桌面上（ mkdir 全称就是 make Directory ，创建一个文件夹）。 如何跳转到上一级文件夹 cd .. 其中 .. 就是上一级文件夹的外号。 如何快速的回到用户主目录呢? cd ~ 或者 cd 都可以。 使用绝对路径进行跳转 上面的跳转形式，都是基于文件夹和我所处的相对位置（相对路径）来进行跳转。但是文件系统上跳转还有另外一种形式叫做使用绝对路径 。 使用绝对路径进行跳转的最大好处，就是跟用户的当前位置无关。 绝对路径的特点是一定以老祖宗文件夹打头，也就是以 / 打头。 例如，不管我们当前位置在哪里，下面操作之后，我们都可以跳转成功 cd / 跳转到老祖宗文件夹中。 cd /home/Liu 可以直接跳转到用户主目录。 Tab 补齐 敲路径的时候，很容易敲错，可以敲出文件夹的打头的字母，然后敲 Tab （或者敲两下 Tab ）就可以自动补齐出完整的文件名了。 总结 知道了如何在文件系统中跳转了，我们就可以进一步学习各种文件操作了（创建，移动，重命名，删除等等）。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:13:42 "},"content/Linux/3-file-man.html":{"url":"content/Linux/3-file-man.html","title":"第三节：文件操作","keywords":"","body":" linux 文件操作 创建文件或者文件夹 文件夹 文件 删除文件或者文件夹 删除一个文件 删除一个文件夹 移动修改操作文件或文件夹 移动 重命名 复制粘贴 拷贝文件夹 操作案例 普通用户和超级用户（文件的管理权限） linux 文件操作 文件操作也包括文件夹操作（ Linux 系统下万物皆文件）。主要涉及： 文件创建：atom/touch 文件夹创建： mkdir 文件夹删除：rm -r folder 文件移动： mv file ../ 文件删除： rm file 创建文件或者文件夹 文件夹 mkdir project 注意：创建的位置要在用户主目录内部，不然会遇到权限不够的问题。 进入这个项目文件夹 cd project 这样，当前文件夹 就切换到了 project 之内。 插播一个小技巧：可以用 pwd （ Print Working Directory 打印当前文件夹）来显示精确的位置。 文件 touch fileName 注意：Windows 系统上，一般文件都是要有后缀，但是 Linux 下没有这个要求。 但是，一般我们都是用 atom 编辑器来创建文件。 atom . 注：. 代表当前位置（当前文件夹）。 删除文件或者文件夹 删除一个文件 rm fileName 删除一个文件夹 rm -r folderName 移动修改操作文件或文件夹 移动 移动用到的是 mv 命令 mv 被移动的文件或者文件夹的路径 目标文件夹位置 重命名 mv 被移动的文件或者文件夹的路径 不存在的位置/文件名 这样进行的就是原来文件的重命名操作。 复制粘贴 用 cp 这个命令。 cp 被拷贝的的文件 目标位置 拷贝文件夹 cp -r 被拷贝的的文件夹 目标位置 操作案例 把 aaa/ 文件夹中的所有文件，都拷贝到 bbb 文件夹中 $ ls aaa aa bb cc $ ls bbb $ mv aaa/* bbb $ ls aaa $ ls bbb aa bb cc 普通用户和超级用户（文件的管理权限） 普通用户就是我们默认登录用户，例如 wentoos 。超级用户就是管理员。普通用户可以化身超级用户。这个化身的方式是 sudo rm fileName 上面的命令可以用超级用户权限来执行一个命令。 sudo su 可以直接化身超级用户。 $ sudo su $ whoami root $ exit $ whoami Liu 上面 root 就是所谓的超级用户。whoami 打印出当前用户的用户名。 超级用户，退出成普通用户，敲 Ctrl-D 。 注意，sudo 操作需要输入密码，输入的就是 wentoos 这个用户的密码，同时，输入密码的时候光标不会移动，这个是正常现象，只管输入，然后回车就可以了 总结一下，了解了文件系统结构，了解各类文件操作（ rm mv cp ），再加上 sudo 的使用，那么一个开发者的基本命令行使用能力就有了。那么我们课程的命令行入门部分就可以告一段落。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:44:28 "},"content/Linux/4-atom.html":{"url":"content/Linux/4-atom.html","title":"第四节：Atom 编辑器","keywords":"","body":" Atom 编辑器 安装 打开一个项目 创建文件 自动补齐 装包 Atom 编辑器 在 Web 开发领域，最受高手追捧的是三款编辑器：vim ，sublime ，atom 。Peter 用 vim 5年，sublime 3年，现在 Peter 用 atom 。Atom 的使用跟 sublime 类似，但是功能更强，所以课程中主力编辑器选择 atom 。vim 太难学，不推荐作为主力编辑器，但是后面涉及服务器管理的时候，还是需要用到 vim 。 安装 深度系统上，到 atom.io 网站，下载 .deb 的包，进行安装。 打开一个项目 cd project/ atom . 创建文件 默认就是用 Ctrl-n ，保存用 Ctrl-s 。 平时使用一个插件来进行文件创建操作，叫做 Advanced New File 。 自动补齐 现在我想输入 h1 就自动补齐成 这个需要安装一个包叫做 emmet 。 装包 使用 Ctrl-Shift-P 打开命令面板，然后搜索 install packages 可以搜到 Install Packages And Themes ，选中，回车，就进入了装包界面。 搜索报名，例如 pigments ，搜到之后，点 install 就可以了。 查看 atom 中已经安装了哪些包，就用 Ctrl-Shift-P 打开命令面板，然后输入 Uninstall Packages 就可以看到所有已经安装的包了。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:45:50 "},"content/Linux/5-sublime.html":{"url":"content/Linux/5-sublime.html","title":"第五节：Sublime 编辑器","keywords":"","body":" 简介 安装 插件 安装 Package Control 快捷键 简介 Sublime Text 是一个代码编辑器（Sublime Text 3是收费软件，但可以无限期试用）。 Sublime 支持多种编程语言的语法高亮、拥有优秀的代码自动完成功能，还拥有代码片段（Snippet ）的功能，可以将常用的代码片段保存起来，在需要时随时调用。 安装 window下百度搜索 sublime 进行下载安装 插件 安装 Package Control 按 Ctrl+` 调出console 粘贴下面安装代码到底部命令行并回车： import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 重启Sublime Text 3。 如果在Perferences->package settings中看到package control这一项，则安装成功。 可以到 官网链接 复制代码或下载 Package Control.sublime-package 放到 sublime 安装目录里的 data 里 installed package 文件夹（这个文件夹位置可能会不一样） 用Package Control安装其他插件 第一种方法：按下Ctrl+Shift+P调出命令面板，输入install 点击 Install Package 选项，然后在列表中搜索并选中要安装的插件 第二种方法：点击工具栏Preferences下的Package Control然后搜索并选中要安装的插件 常用插件 Package Control（插件包控制插件） 安装SublimeText后必须安装的东西，插件包控制插件。 可以控制插件的查看已安装差价、安装、升级、删除等操作 ChineseLocalization （汉化插件） 工具栏 Help 下的 Language 选项选择语言 Emmet （自动补齐插件） 输入简写，按Tab键可触发效果 Bable（React JSX） 具有React JSX扩展名的ES6 JavaScript的语法定义（语法高亮） Agila（主题） 一款受欢迎的sublime Theme 快捷键 Ctrl+L 选择整行（按住-继续选择下行） Ctrl+KK 从光标处删除至行尾 Ctrl+K Backspace 从光标处删除至行首 Ctrl+J 合并行（已选择需要合并的多行时） Ctrl+KU 改为大写 Ctrl+KL 改为小写 Ctrl+D 选择字符串 （按住-继续选择下个相同的字符串） Ctrl+M 光标移动至括号内开始或结束的位置 Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果） Ctrl+Shift+c转换为utf8 Ctrl+R 搜索指定文件的函数标签 Ctrl+G 跳转到指定行 Ctrl+KT 折叠属性 Ctrl+K0 展开所有 Ctrl+U 软撤销 Ctrl+T 词互换 Tab 缩进 自动完成 Shift+Tab 去除缩进 Ctrl+F2 设置书签. F2 下一个书签 Shift+F2 上一个书签 shift+鼠标右键 列选择 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑 Alt+. 闭合当前标签 F6 检测语法错误 F9 行排序(按a-z) F11 全屏模式 Ctrl+Enter 光标后插入行 Ctrl+Shift+Enter 光标前插入行 Ctrl+Shift+[ 折叠代码 Ctrl+Shift+] 展开代码 Ctrl+Shift+↑ 与上行互换 Ctrl+Shift+↓ 与下行互换 Ctrl+Shift+A 选择光标位置父标签对儿 Ctrl+Shift+D 复制光标所在整行，插入在该行之前 ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找 Ctrl+Shift+K 删除整行 Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行 Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号） Ctrl+Shift+P 打开命令面板 Ctrl+Shift+/ 注释已选择内容 Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换 Ctrl+鼠标左键 可以同时选择要编辑的多处文本 Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择 Shift+Tab 去除缩进 Alt+Shift+1~9（非小键盘）屏幕显示相等数字的小窗口 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:46:37 "},"content/Linux/6-github.html":{"url":"content/Linux/6-github.html","title":"第六节：学习 Github","keywords":"","body":" Github 注册 Github 账号 搭建 Github 网站 Github Github.com 是程序员存放代码的一个网站。Github Pages 是 Github 提供的一项服务，可以免费的帮助我们托管网站。 注册 Github 账号 点 github.com 首页的 Sign Up （注册）按钮，进行注册。 填写 username （用户名），小写英文字母加数字，不要用空格。 Email 这一项，必须填写真实有效的邮箱，不然注册不了 Choose your personal Plan ? 选择你的付费方案 免费版：无限使用权限，只能发布开源项目 收费版：允许发布闭源项目 邮箱中点链接之后，就可以自动跳转回 github.com 的页面上，同时显示 Your email was verified. 你的邮箱已经验证成功了。下一步就可以来创建项目了。 repository （仓库）这个词基本上等价于 project ，差别如下： repository = project + history 搭建 Github 网站 创建一个仓库，仓库的名字是有严格规定的， username.github.io 把 username 替换成自己的自己的用户名。例如我叫 l ，我要创建的仓库名就是 wentoos.github.io Description (optional) 项目描述（可选项） Public: 开源项目 Private：闭源项目 Initialize this repository with a README 初始化项目的时候，自动添加一个 README 文件，我们这里勾选上这一项。 到达项目页面后，现在来创建一个 index.html ，点 “Create A New File” 添加一些基本的 html 内容进 index.html ，然后点 “Commit New File” 进行保存。 注意：新添加的内容，不一定立刻能显示到 wentoos.github.io ，可能会有五六分钟的延迟。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:47:21 "},"content/Linux/7-hello-git.html":{"url":"content/Linux/7-hello-git.html","title":"第七节：你好 Git","keywords":"","body":" 你好 Git Github 的正确使用姿势 安装 Git 你好 Git Git 和 Github 是两个东西。Git 是一个软件，作者是 Linus ，安装到我们的笔记本上。Github 是一个网站，作者是 Tom ，浏览器中访问 github.com 可以使用。 Github 的正确使用姿势 直接到 Github.com 上点 New File 按钮，不是 正确的使用方法。要了解正确的 Github 使用方法，首先要知道什么是 Git 。 Git 是一个版本控制工具，通常我们都是通过本地 Git 和 Github 的互动来完成版本控制工作的。 通常我们的 Github 工作流是这样的： 第一步，在我们自己的笔记本上安装 Atom 和 Git 第二步，注册 Github 账号，并开启新仓库 第三步，在笔记本上做代码开发 第四步，通过 git push 命令来上传代码到 Github OK，从上面流程可见，如果想要灵活运用 Github ，第一步先要学会 Git 的基本使用技巧。下面几个部分中，我们先来介绍 Git 的使用。 安装 Git sudo apt-get update sudo apt-get install git 注：apt-get 是 ubuntu 系统（ deepin 其实就是 ubuntu 的一个变种）的安装软件的命令。装软件的过程其实非常复杂，涉及到软件包依赖关系管理，这个原来 Peter 做过专职的一年的这个工作。这个领域的深入知识，应该是系统管理员（ sys admin ）去掌握，我们开发者没必要学那么深。 验证有没有装好，就敲 git --version 如果可以正确输出版本号，证明 Git 已经装好了。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:48:00 "},"content/Linux/8-local-git.html":{"url":"content/Linux/8-local-git.html","title":"第八节：Git本地工作流","keywords":"","body":" Git 本地工作流 下面来走一个 Git 本地工作流的 Demo 查看改版历史 忽略特定文件或者文件夹 总结 Git 本地工作流 Git 是一个版本控制工具，什么是版本控制，我们下面实际操作一下就一目了然了。 Git 本地工作流（没有网络操作）可以分为以下几步： 第一步，使用 atom 创建并编辑项目 第二步，使用 git init 命令，把一个普通项目变成一个Git 仓库 第三步，使用 git add -A 命令，添加修改内容到 Git 第四步，使用 git commit -m\"my commit msg\" 命令，制作一个版本 下面来走一个 Git 本地工作流的 Demo 首先，我们先来创建一个项目： mkdir trygit 然后进入项目，开始添加一个 index.html 文件 cd trygit atom . 现在我们来把一个 普通项目变成一个仓库 ，需要执行 $ git init Initialized empty Git repository in /Users/peter/Desktop/project/.git/ init 是英文 initialization （初始化）的缩写。 输出信息的英文意思是： 已经在 /Users/peter/Desktop/project/.git/ 初始化了一个空的 git 仓库 运行这个命令之后，如果我们敲 ls 会看到没有任何变化。因为，命令创建的 .git 文件夹是一个隐藏文件夹（所有以点开头的文件或者文件夹在 Linux 系统下都是隐藏的）。 要查看隐藏文件夹，可以敲 ls -a 这样可以看到输出中包含 .git 文件夹了。 .git 文件夹是 Git 仓库的心脏，未来所有的版本历史都会保存在 .git 文件夹中。所以 仓库 == 项目 + .git/改版历史 注：仓库 ，英文是 Repo ，是我们使用 Git，Github 必须要了解的一个概念。 如果要制作一个版本，一共分两步：添加修改和制作版本。 首先来添加修改到 git ： git add -A 注： -A 的意思是添加“所有当前修改内容” 要想把添加的内容制作成版本，还需要执行 git commit -m\"I add a file\" 注： commit 的意思是”做一件很重要的事”，但是在 git 这里，它的意思就是版本 。-m 就是 message 的简写，后面的内容是再版留言 。 问题来了，新用户首次执行上面的命令，会看到下面的报错信息 please tell me who you are 解决方法是，运行下面的命令 git config --global user.name \"Peter Wang\" git config --global user.email \"happypeter1983@gmail.com\" 来设置用户名和邮箱。这样再次执行 $ git commit -m\"I add a file\" [master (root-commit) dcb0329] I add index.html 1 file changed, 1 insertion(+) create mode 100644 index.html 就可以成功制作一个版本了。也就是 Git 本地工作流就完成了一个完整的循环。 后续如果再做第二第三个版本，就是只需要： 修改内容用 atom git add -A git commit -m\"msg\" 即可。 注意：一个项目中 git init 只需要执行一次就可以了。 查看改版历史 改版历史（所有我们做过的版本组成的一条线，就叫历史）中，会包含多个版本。每个版本中起码要包含4个 W （ Who When What Why ）。 那么如何来查看改版历史呢？ git log -p log 是日志的意思。-p 是 patch （补丁，也就是修改内容）的缩写。 小技巧：q 可以退出 git log -p 的界面，敲 j 可以往下翻，敲 k 可以往上翻。 注意，实际中 Peter 查看版本历史从来不用 git log 命令，而是使用一个前端工具叫做 tig 。安装和使用方式可以参考：http://www.haoduoshipin.com/v/49.html 忽略特定文件或者文件夹 有时候，项目文件夹中有一些文件或者文件夹，并不是我们写的代码，例如 node_modules 。那么我们就没有必要把它们进行版本控制，这样我们可以吧这个文件或者文件夹的名字添加到，项目文件夹内的一个特殊文件，叫做 .gitignore 中。 cd project/ atom .gitignore 然后，.gitignore 中填写如下内容： node_modules 这样，git 就会忽略 node_modules 文件夹，以及里面的所有文件了。 没有 .gitignore 的技巧，我们就会把 node_modules 中的文件也进行版本控制，这样带来两个明显不爽的现象： 版本历史混乱 git push 到 github.com 就会很慢 所以，我们需要学习 .gitignore 的配置技巧。 总结 这样，我们就学会了如何在本地创建 git 版本，查看各个版本 ，下面一节我们来研究如何把本地的这些版本上传到 github.com 。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:50:13 "},"content/Linux/9-push.html":{"url":"content/Linux/9-push.html","title":"第九节：上传代码到Github.com","keywords":"","body":" 上传代码到 Github.com 准备工作：删除已创建的项目 第一步：创建本地项目 第二步：创建 github.com 上的同名仓库 尝试推送 push 第三步：添加 ssh key Github Pages 显示网站 Jekyll 框架 Jekyll: 添加布局文件 Jekyll: 引用 main.css git clone 命令 git 各个命令的作用 学习 Github/Git 的学习目标 承前启后 上传代码到 Github.com 前面学会了如何在本地用 git 创建项目版本，本节咱们看看咋把新版本上传到 github.com 之上。 准备工作：删除已创建的项目 如何删除一个 github.com 的仓库呢？ 首先到仓库页面：https://github.com/wentoos/wentoos.github.io 点 Settings（设置）这一个标签。打开的页面底部有一个 “Delete this repository” 按钮，意思是”删除这个仓库“，点击按钮。打开的界面中，输入一下这个仓库的名字 wentoos.github.io 就可以把这个仓库删除了。 删除仓库之后，我们要做的事情是： 如何把本地的已有仓库，上传到 github.com 第一步：创建本地项目 项目名称是任意的，但是我们这里想做的事情是上传比较，所以，本地这个仓库名，也必须是： mkdir wentoos.github.io 本地项目名要和 github.com 我们一会儿要创建的仓库名保持一致。 然后，我们就可以把我们想要上传的内容拷贝到这个文件夹内，并制作本地版本。 拷贝进来的内容，要符合第一天我们介绍的 github pages 的格式规范（其实最重要的一点就是每个 .md 文件中都要有头部，参考第一天我们的文档中的介绍）。 第二步：创建 github.com 上的同名仓库 到 github.com 上点 New repository 按钮，新建一个项目， 项目名叫做 wentoos.github.io 。 注意，不要勾选任何选项，尤其是不能默认创建 README.md 文件。 创建完成之后，页面上有两个选择，其中第二个是 or push an existing repository from the command line 翻译：或者把一个已经存在的仓库从命令行推送上来 我们当前就属于这个情况。上传方式有两种 HTTPS 和 SSH ，我们推荐的方式是 SSH，点一下页面上 SSH 字样的按钮。 接下来就按照页面上显示的两步来走。 尝试推送 push 到本地命令行，进入我们的本地项目文件夹 cd wentoos.github.io 然后执行下面两步： git remote add origin git@github.com:funnydeer/funnydeer.github.io.git git push -u origin master 如上所示： git@github.com:funnydeer/funnydeer.github.io.git 这个是远端仓库地址。第一个命令本身的意思是把远端仓库地址记录到本地仓库中。 下一步 git push -u origin master 就是真正进行上传代码的工作了。 但是执行结果是： Please make sure you have the correct access rights 执行失败，解决方法就是添加 ssh 公钥到 github.com 。 第三步：添加 ssh key 现在需要达成开发机和 github.com 的互信。 因为开发过程中，我们需要用本地机器向 github.com 的仓库中 写东西（ git push ），同时我们又不想每次都输入密码，所以我们就用 ssh key 的形式来达成互信，过程如下： 在本地机器上生成一对 ssh key ，一个公钥，一个私钥 把公钥添加到 github.com 具体操作如下： 首先本地运行 ssh-keygen 命令，可以在 ~/.ssh 文件夹下生产 ssh key 到 ~/.ssh/id_rsa.pub 也就是公钥文件中，拷贝公钥字符串 把字符串粘贴到 github.com -> setting -> ssh keys -> add 这样添加 ssh key 的工作就完成了，以后我们执行 git push 这样的命令就不会看到如下错误了： ...permission denied... ...make sure ... correct access right ... 大功告成。 Github Pages 显示网站 上面的步骤操作完成，就可以在 l552177239.github.io 看到网站的首页了。 当然我们这里依然是使用 Github Pages 服务，所以是可以添加 md 文件的。 下面，我们涉及到如何把网站做的好看一些的问题。这个需要了解 github Pages 底层的机制。底层 Github Pages 采用了 Jekyll 框架。 Jekyll 框架 要把 Github Pages 的网站做漂亮，必须了解 Jekyll 框架如何运行的。 首先，.md 文件，也就是 markdown 格式的支持，就是 Jekyll 提供给我们的。这个前面已经详细介绍过了。 现在，我们来添加布局文件 英文参考文档：官网 中文参考文档（有可能过期）： 中文网 Jekyll: 添加布局文件 首先打开所有的 .md 中的头部改成这样 --- title: First Page layout: default --- 然后来创建布局文件 default.html ，这个文件必须存放到 layouts 文件夹之内， _layouts/default.html 内容如下，可以参考我的其他项目中的写法。例如： anything anything content anything anything 注意，上面的 content 外面要套两个大括号。 anything anything 可以替换成任意字符端，当然也可以替换成 html 代码。所以就可以给 .md 文件引入 main.css 了。_ Jekyll: 引用 main.css layouts/default.html 中这样写 content 注意：上面的 content 外面要套两层大括号。另外，特别要注意的是 main.css 一定不能写到 layouts 文件夹，或者任意的以 打头的文件夹内。_ 当前，我们的 main.css 要放到项目顶级文件夹下的 css 文件夹之内 css/main.css body { background: #bada55; } git clone 命令 要想把 github 上的一个项目代码下载到本地有两种方式，一种就是普通下载（ download ）。但是，开发者 基本上会选择另外一种方式，就是 clone 。 git clone clone 的特点就是不仅仅可以得到最新代码，而且可以得到整个改版历史。而普通下载只能得到最新版本。 git 各个命令的作用 git push 把本地仓库中有，而远端对应仓库中没有的版本推送到远端 git pull 把远端仓库中有，而本地对应仓库中没有的版本拉到本地 git clone 把远端仓库，克隆到本地 学习 Github/Git 的学习目标 知道 git 是 版本控制 工具 每个同学要有一个 github 仓库 已经添加 ssh key 互信，也就是可以从本地仓库推送内容（ git push ）到 github 仓库 可以在本地仓库中任意添加，删除，修改文件，并作成版本 这样，github/git 的初级使用我们就有能力完成了。但是，作为成熟开发者，github 上面会发 push request ，本地 git 会开启新分支，都是必备知识。暂时我们先不涉及。 承前启后 程序员三大基本工具 编辑器 atom 命令行 Linux 版本控制 Git/Github 学习上面三大工具的目的，就是为了更加高效的写代码 。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:57:27 "},"content/Linux/10-gitbook.html":{"url":"content/Linux/10-gitbook.html","title":"第十节：学习 Gitbook","keywords":"","body":" 使用 Gitbook 来做笔记 安装 Gitbook 工具 托管gitbook 部署书籍到 gh-pages 手动 使用 gh-pages 插件完成 编辑书籍 使用 Gitbook 来做笔记 安装 Gitbook 工具 装包： npm install gitbook-cli -g 创建笔记文件夹note并进入 mkdir note && cd note 初始化gitbook gitbook init 这样，会生成2个文件 - README.md 封面 - SUMMARY.md 目录 启动项目： gitbook serve 这样，可以启动一个服务器，然后到 localhost:4000 端口，就可以看到这本书了。 在浏览器打开： localhost:4000 调整结构：新建content文件夹将README.md,SUMMARY.md文件放在里面 创建 git 文件夹，然后里面就可以写笔记了。其实 gitbook 本身的使用技巧基本就是这些了。 托管gitbook 在github上创建node仓库 然后，把项目变成一个 nodejs 的项目： npm init -y 然后，在package.json 中添加这些代码： \"scripts\": { \"start\": \"gitbook serve ./content ./gh-pages\", \"build\": \"gitbook build ./content ./gh-pages\", \"deploy\": \"node ./scripts/deploy-gh-pages.js\", \"publish\": \"npm run build && npm run deploy\", \"port\": \"lsof -i :35729\" }, 运行本地gitbook npm start 删除_book文件夹 rm -r _book 在note文件夹里创建一个.gitignore文件将不上传的文件添加 # dependencies /node_modules /scripts /gh-pages github备份（上传）操作git init git add -A git commit -a -m 'new' git remote add origin https://github.com/l552177239/note.git git push -u origin master 部署书籍到 gh-pages 手动 这一步，可以手动做： 第一步：运行：npm run build，把md文件转化为html放到gh-pages文件夹 第二步：拷贝gh-pages中的所有文件，到gh-pages分支，然后上传 第三步：以后每次修改完都拷贝到gh-pages分支，很麻烦 使用 gh-pages 插件完成 装包： npm i gh-pages --save 然后创建 note/scripts/deploy-gh-pages.js 将下面代码拷贝进去 'use strict'; var ghpages = require('gh-pages'); main(); function main() { ghpages.publish('./gh-pages', console.error.bind(console)); } 这样，每次书稿有了修改，运行 npm run publish 就可以把书稿部署到 http://wentoos.github.io/note 编辑书籍 可以修改 SUMMARY.md 来添加书籍目录 # Summary * [Introduction](README.md) * 第一章 - [第一小节：学习 Github](./git/1-github.md) - [第二小节：学习 Gitbook](./git/2-gitbook.md) - [第三小节：Github 基本操作](./git/3-github.md) Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:02:43 "},"content/Linux/11-markdown.html":{"url":"content/Linux/11-markdown.html","title":"第十一节：Markdown 语法","keywords":"","body":" Markdown 标题 锚点 引用 列表 代码 强调 斜体： 加粗： 自动链接 表格 分割线 上下标 图片 标题 Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown是一种轻量级标记语言，目标是实现「易读易写」。 标题 在Markdown中，你只需要在文本前面加上# 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加# 即可，标题字号相应降低。例如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 锚点 Coding 会针对每个标题，在解析时都会添加锚点id，如 # 锚点 会被解析成： 锚点 注意我们添加了一个user-content-的前缀所以如果要自己添加跳转链接要使用markdown的形式，且链接要加一个’user-content-‘前缀，如： [问内链接](#user-content-锚点); 引用 Markdown 标记区块引用是使用类似 email 中用 > 的引用方式，只需要在整个段落的第一行最前面加上 > ： > Coding.net 为软件开发者提供基于云计算技术的软件开发平台，包括项目管理，代码托管，运行空间和质量控制等等。 区块引用可以嵌套，只要根据层次加上不同数量的 > ： > 这是第一级引用。 > > > 这是第二级引用。 > > 现在回到第一级引用。 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： > ## 这是一个标题。 > > 1. 这是第一行列表项。 > 2. 这是第二行列表项。 > > 给出一些例子代码： > > return shell_exec(\"echo $input | $markdown_script\"); 列表 列表项目标记通常放在最左边，项目标记后面要接一个字符的空格。 无序列表：使用星号、加号或是减号作为列表标记 - Red - Green - Blue 有序列表：使用数字接着一个英文句点 1. Red 2. Green 3. Blue 如果要在列表项目内放进引用，那 > 就需要缩进： * Coding.net有以下主要功能: > 代码托管平台 > 在线运行环境 > 代码质量监控 > 项目管理平台 代办列表: 表示列表是否勾选状态 - [ ] 不勾选 - [x] 勾选 代码 只要把你的代码块包裹在 ``` 之间，你就不需要通过无休止的缩进来标记代码块了。 在围栏式代码块中，你可以指定一个可选的语言标识符，然后我们就可以为它启用语法着色了。 举个例子，这样可以为一段 Ruby 代码着色： require 'redcarpet' markdown = Redcarpet.new(\"Hello World!\") puts markdown.to_html 强调 在Markdown中，可以使用 * 和 _ 来表示斜体和加粗。 斜体： *Coding，让开发更简单* _Coding，让开发更简单_ 加粗： **Coding，让开发更简单** __Coding，让开发更简单__ 自动链接 方括号显示说明，圆括号内显示网址， Markdown 会自动把它转成链接，例如： [Github首页](https://github.com/) 或者也可以直接用，将网址或者邮箱地址放在中间，也能将地址直接转成链接： 表格 在 Markdown 中，可以制作表格，例如： First Header | Second Header | Third Header ------------ | ------------- | ------------ Content Cell | Content Cell | Content Cell Content Cell | Content Cell | Content Cell 或者也可以让表格两边内容对齐，中间内容居中，例如： First Header | Second Header | Third Header :----------- | :-----------: | -----------: Left | Center | Right Left | Center | Right 分割线 在 Markdown 中，可以制作分割线，例如： --- 上下标 \\^表示上标, _表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。 例如： x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} 图片 Markdown 使用了类似链接的语法来插入图片, 包含两种形式: 内联 和 引用. 内联图片语法如下: ![Alt text](/path/to/img.jpg) 或 ![Alt text](/path/to/img.jpg \"Optional title\") 也就是: 一个感叹号: ! ; 紧跟一对方括号, 包含了可选填的图片 alt 属性; 紧跟一对圆括号, 包含了图片的 URL 或者路径, 以及一个可选的用单引号或双引号包裹的 title 属性. 引用图片语法如下: ![Alt text][id] “id” 是图片引用的名称. 图片引用使用链接定义的相同语法: [id]: url/to/image \"Optional title attribute\" 标题 --- title:标题 --- Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:07:18 "},"content/ES6/1-hello-es6.html":{"url":"content/ES6/1-hello-es6.html","title":"第一节：Hello ES6","keywords":"","body":"什么是ES6？ 2015年6月17日，ECMA国际组织发布了 ECMAScript 的第六版，该版本正式名称为ECMAScript 2015（ES2015），但通常被称为 ECMAScript 6 或者ES6。 ECMAScript 和 JavaScript 的关系？ Babel 转码器 Js的严格模式（Es5添加的） 最常用的ES6特性 ECMAScript 和 JavaScript 的关系？ ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。 Babel 转码器 Babel是一个广泛使用的ES6转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看： 点击跳转Babel官网地址 Js的严格模式（Es5添加的） \"use strict\"; 最常用的ES6特性 let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments 这些是ES6最常用的几个语法，也是ES6的重点。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-12 15:36:02 "},"content/ES6/2-let.html":{"url":"content/ES6/2-let.html","title":"第二节：Let","keywords":"","body":"Let 语句 let（声明变量）声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。 let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，var声明的变量只能是全局或者整个函数块的。 块级作用域 不存在变量提升 暂时性死区 不允许重复声明 块级作用域 let实际上为 JavaScript 新增了块级作用域。 （let被限制在大括号里{}） function f1() { let n = 5; if (true) { let n = 10; } console.log(n); // 5 } let声明的变量只在它所在的代码块有效 { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 ES6 允许块级作用域的任意嵌套且外层作用域无法读取内层作用域的变量 { { {let insane = 'Hello World'} console.log(insane); // 报错 } }; 内层作用域可以定义外层作用域的同名变量 { let insane = 'Hello World'; {let insane = 'Hello World'} }; 不存在变量提升 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 暂时性死区 if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。 function () { let a = 10; var a = 1; } // 报错 function () { let a = 10; let a = 1; } // 报错 因此，不能在函数内部重新声明参数。 function func(arg) { let arg; // 报错 } function func(arg) { { let arg; // 不报错 } } Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-12 15:36:43 "},"content/ES6/3-const.html":{"url":"content/ES6/3-const.html","title":"第三节：Const","keywords":"","body":"Const 语句 const 声明一个只读的常量 一旦声明，常量的值就不能改变。常量是块级作用域。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const一旦声明变量，就必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错。 const foo; // SyntaxError: Missing initializer in const declaration const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 不可重复声明。 将一个对象声明为常量必须非常小心。 ES6声明变量的六种方法 将一个对象声明为常量必须非常小心。 const a = []; a.push('Hello'); // 可执行 a.length = 0; // 可执行 a = ['Dave']; // 报错 可以修改（追加）a下的属性，不容许修改他本身的值 ES6声明变量的六种方法 ES5 只有两种声明变量的方法： var命令和function命令 ES6除了添加let和const命令 后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 17:28:09 "},"content/ES6/4-Destructuring.html":{"url":"content/ES6/4-Destructuring.html","title":"第四节：变量的解构赋值","keywords":"","body":" 数组的解构赋值 Rest 参数 数组的扩展用 ... 展开 对象的解构赋值 对象的解构赋值是下面形式的简写 字符串的解构赋值 对象的结构赋值： 对象的扩展（合并） 数组的解构赋值 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 let [a, b, c] = [1, 2, 3] 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 注意 let数组里的值，可以是数字、变量、对象、函数等、但无法拿到空格占位。 let [a,b,c,d,,] = [1,\"aaa\",{name:'sayname'},function(){}]; console.log(a,b,c,d); Rest 参数 rest参数只包括那些没有给出名称的参数，arguments包含所有参数； arguments对象不是真正的array，而rest参数是Array的实例，可以直接应用sort, map, forEach, pop等方法； arguments对象拥有一些自己额外的功能。 Rest参数接收函数的多余参数，组成一个数组，放在形参的最后，形式如下： function func(a, b, ...theArgs) { // ... } 例：剩余参数数组里值的和 var sum = (a,...rest) => { let rests = 0 for(let i=0;i数组的扩展用 ... 展开 例子：连接两个数组 let arr1 = [1,2,3,4] let arr2 = [5,6,7,8] //ES5写法：var arr = arr1.concat(arr2,[9]) var arr = [...arr1,...arr2,9] console.log(arr) 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 对象的解构赋值 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果变量名与属性名不一致，必须写成下面这样。 var { foo: baz } = { foo: 'aaa', bar: 'bbb' }; baz // \"aaa\" let obj = { first: 'hello', last: 'world' }; let { first: f, last: l } = obj; f // 'hello' l // 'world' 例子：利用对象解构赋值变量取属性同名的值 //父组件 Some contents... Some contents... Some contents... Some contents... 子组件想拿到父组件里的同名属性 let {title,children,cancelText,okText} = this.props //等同于声明一个变量等于this.props下的同名属性 //let title = this.props.title等等 //下面使用时不用再写this.props.title可以代替直接用title代替 let hello = ({name,age}) => ( console.log(`my name:${name},age:${age}`) ) hello({name:'Liu',age:'24'}) 对象的解构赋值是下面形式的简写 let { foo: foo, bar: bar } = { foo: \"aaa\", bar: \"bbb\" }; //简写形式：let{foo,bar}={foo: \"aaa\", bar: \"bbb\"} 将obj中的对象foo赋值给一个变量。 let obj = {bar:'bbb',foo:'aaa',name:'sayname'}; let {foo} = obj; console.log(foo); var foo = obj.foo; 字符串的解构赋值 按字符串下标赋值。 const [a, b, c, d, e] = 'hello'; a // \"h\" b // \"e\" c // \"l\" d // \"l\" e // \"o\" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 let {length : len} = 'hello'; len // 5 对象的结构赋值： let name = 'liuenqing'; let age = 22; let say = function(){ console.log(1) } let obj = { name, age, say, run(){ console.log('run') } } console.log(obj) 对象的扩展（合并） let obj1 = {name:'Liu'} let obj2 = {age:'24',Gender:'man'} Object.Assign({},obj1,obj2) //必须都为对象 //obj.name会对name的值进行字符串解构 更为强大的 ... let obj1 = {name:'Liu'} let obj2 = {age:'24',Gender:'man'} var obj = {...obj1,...obj2,say(){}} console.log(obj) Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:13:20 "},"content/ES6/5-function.html":{"url":"content/ES6/5-function.html","title":"第五节：箭头函数","keywords":"","body":" 箭头函数 匿名箭头函数 箭头函数的 this 指向 箭头函数 ES6允许使用“箭头”（ => ）定义函数。 let [函数名] = (参数) => ( 返回值 ) 等同于下面函数 function [函数名]([参数]){ return ( 返回值 ) } 注意：箭头函数的参数小括号，一位参数时可以省略小括号。 如果函数执行多条js语句，用 {} 包裹。 如果有返回值使用 return 返回 let [函数名] = (参数) => { js语句; return ( 返回值 ) } 如果函数返回对象，用 ({}) 包裹 let [函数名] = (参数) => ({ js语句; return ( 返回值 ) }) 匿名箭头函数 setTimeout(function(){ console.log('a') } ,1000) 可以写为 setTimeout( () => console.log('a') ,3000) 箭头函数的 this 指向 let sun = () => console.log(this); sun() 指向定义时所在的对象，而不是使用时所在的对象。 普通函数指向window function sun(){ console.log(this) }; sun() //undefined 在严格模式下输出undefined 箭头函数指向的this在声明时就会绑定，以后所有的this都指向声明时的this。 function foo() { setTimeout(() => { console.log('id:', this.id); }, 100); } var id = 21; foo.call({ id: 42 }); 箭头函数里的this指向本身，也就是foo，执行foo的时候指向foo的id替换为42 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:13:04 "},"content/ES6/6-string.html":{"url":"content/ES6/6-string.html","title":"第六节：字符串的扩展","keywords":"","body":" 字符串的扩展 字符串模版（template string） 字符串的扩展 字符串模版（template string） 字符串模板是增强版的字符串，用反引号（ ）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 模板字符串中嵌入变量，需要将变量名写在 ${} 之中。 let obj = {name:'Liu',age:'24'}; `my name is :${obj.name}` 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 var a = 3; var b = 2; `运算：${a} + ${b} = ${a + b}` Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:09:22 "},"content/ES6/7-class.html":{"url":"content/ES6/7-class.html","title":"第七节：Class的基本语法与继承","keywords":"","body":" Class 的基础语法与继承 JS构造函数 Class 的基础语法与继承 JS构造函数 function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () { return '(' + this.x + ', ' + this.y + ')'; }; var p = new Point(1, 2); 通过class关键字（语法糖），可以定义类。 class下只能写方法，方法之间不用符号隔开 constructor（构造器）class方法中的特殊方法，只要调用class就会自动执行，接受实例对象的参数 extends（继承） super继承父类的属性 class Person { //私有方法 constructor(name) { this.name = name; } say(){ console.log(say) } //公有方法 } class Women extends Person{ constructor(tall,name){ super(name) this.tall = tall } run(){ console.log(run) } } var person = new Women() console.log(person) Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:13:06 "},"content/ES6/8-Module.html":{"url":"content/ES6/8-Module.html","title":"第八节：模块的基本语法","keywords":"","body":" 模块(Module) 导出：export 导入： 命名导入 直接导入 模块(Module) 导出：export 命名导出 var a = 1 var b = 2 var person = () => console.log('a') export { a,b,person } 默认导出 export default App 导入： import 命名导入 as 改变命名导出的名字 import {a as c,b,person} from './app' console.log(c,b,person) a作为c导入，a可以再次使用，并不会被覆盖 全部导入（ * ） import * as c from './app' console.log(c) 直接导入 import './app' 会把导入的代码整体粘贴过来 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:13:07 "},"content/React/1-react-setup.html":{"url":"content/React/1-react-setup.html","title":"第一节：React环境快速配置","keywords":"","body":" React环境快速配置 第一步安装git bash； 第二步安装node.js； 第三步安装npm； 第四步安装react； 第五步安装插件； React环境快速配置 第一步安装git bash； https://git-scm.com/download/win 第二步安装node.js； https://nodejs.org/dist/v6.10.3/node-v6.10.3-x64.msi 第三步安装npm； npm install -g cnpm --registry=https://registry.npm.taobao.org 第四步安装react； npm install -g create-react-app 第五步安装插件； axios（ajax）： npm install axios --save react-router-dom（路由库）： npm install react-router-dom --save jquery（JS工具库）： npm install jquery --save bootstrap（前端开发框架）： npm install bootstrap --save moment（JS日期处理库）： npm install moment --save prop-types（React组件属性类型校验）： npm install prop-types --save react-addons-css-transition-group（react-router过渡动画）： npm install react-addons-css-transition-group --save Material-UI（react UI库）： npm install material-ui react-tap-event-plugin --save ANT Desgin（阿里UI）： npm install antd --save Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:18:02 "},"content/React/2-create-react-app.html":{"url":"content/React/2-create-react-app.html","title":"第二节：React环境配置","keywords":"","body":" Git安装及设置 git 第一步 安装git 第二步 基本操作 第三步 推送代码 Node安装及设置 第一步 安装nvm 第二步 设置nodo 配置React环境 第一步 安装React 第二步 配置 运行React 用Yarn装包 配置package.json文件 安装React出错（环境配置出错），在命令行执行下面命令 Git安装及设置 git 第一步 安装git 在 linux 下直接使用命令：sudo apt-get install git windows 下百度 gitbash ，下载安装即可 在mac 下：brew install git 第二步 基本操作 查看已有的配置信息：git config --list 创建 demo 文件夹：mkdir demo 初始化：git init 将 github 上的仓库克隆到本地：git clone [仓库地址] 查看做了哪些修改：git diff（按 q 退出） 创建a.html：touch a.html 进入编辑.gitignore：vim .gitignore 添加：/[文件夹名] 将文件添加到缓存获得 Git 的跟踪：git add（. -A * ） 查看当前版本库各个文件的状态：git status 将缓存区内容添加到仓库中：git commit '版本留言，尽量写的语义话'：git commit -m 查看提交记录：git log 取消已经缓存的内容：git reset 也可以通过版本号回滚：git reset --hard [版本号] 把一个文件删除，并把它从git的仓库中移除：git rm [文件名] 取消对某个文件的修改：git checkout [文件名] 忽略上传的文件：vi.gitignore 创建新分支：git branch [yourbranch] 切换分支：git checkout [yourbranch] 或者直接创建一个分支，并且切换过去： git checkout -b [yourbranch] 删除分支：git branch -d [yourbranch] 推送分支：git push origin [yourbranch] 第三步 推送代码 首次推送：git push -u origin master 之后可以省略参数：git push 如果没有通过 clone 现有仓库，而是直接在本地 git init 的仓库的话，需要先添加远程仓库地址。 为这个仓库添加一个远程地址：git remote add origin [你的github上的仓库地址] 设置 public key 首先需要在本地机器上生成 key：ssh-keygen 这时，会在 ~/.ssh/ 文件夹之下生成一对 ssh key ，包括一个 public key 和一个 private key 。（如果是windows用户，这个文件一般会在这里：C:\\Users\\Administrator.ssh） 复制 public key：cat ~/.ssh/id_rsa.pub 将拷贝的 public key 添加在github账户上： 右上角点击头像-> 点击settings-> 点击SSH KEYS-> 点击ADD SSH KEYS-> 将获取的public key粘贴于此 Node安装及设置 第一步 安装nvm linux：curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash windows：node官网下载相应版本安装 安装node 查看有哪些版本可以安装：nvm ls-remote 安装版本 v5.10.1：nvm install v5.10.1 第二步 设置nodo 查看版本：node -v 使用淘宝定制的 cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org 检查淘宝定制：cnpm install gulp npm 命令： 查看全局插件命令：npm list -g --depth 删除全局环境下yarn包：npm uninstall yarn -g 配置React环境 第一步 安装React 安装 create-react-app：npm install -g create-react-app 安装淘宝的npm源：npm config set registry https://registry.npm.taobao.org 第二步 配置 构建一个 react 的前端工程：create-react-app [工程名] 启动工程：npm start 运行React 在项目文件夹下src文件夹中的index.js中写代码 用Yarn装包 1.安装yarn：npm install yarn -g 2.测试能否运行：yarn --version 3.初始化： yarn init 4.用yarn安装react：yarn add react 5.用yarn安装webpack在工具中：yarn add -D webpack 6.删除一个依赖包：yarn remove [package] 7.安装所有的依赖包：yarn或yarn install 8.运行package.json中的脚本：yarn run build 9.卸载包：yarn remove jquery 关于yarn与npm更多：脚本之家文章 配置package.json文件 scriptes脚本中写入run命令 \"scripts\": { \"build\": \"rimraf dist && ./node_modules/.bin/webpack --config webpack.prod.config.js\", \"dev\": \"./node_modules/.bin/webpack-dev-server --config webpack.dev.config.js\" }, 在命令行输入npm run dev会执行\"./node_modules/.bin/webpack-dev-server --config webpack.dev.config.js\" 创建隐藏配置文件 vi .npmrc 找到.npmrc.swp 输入i进入插入模式，将下面文字放入 loglevel=http 点击Esc点击shift+ZZ保存退出 安装React出错（环境配置出错），在命令行执行下面命令 npm config set cache C:\\[用户名]\\nodejs\\npm-cache --global Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:33:44 "},"content/React/3-npm.html":{"url":"content/React/3-npm.html","title":"第三节：npm语句","keywords":"","body":" npm 装包 安装工具 全局安装 卸载 查看全局插件命令： npm NPM的全称是Node Package Manager，是随同NodeJS一起安装的包管理和分发工具，它很方便让JavaScript开发者下载、安装、上传以及管理已经安装的包。 装包 npm install [包名]@3.9.1 --save //简写：npm i //@3.9.1：指定版本号 //--save：将包添加到packae.json 安装工具 npm install [包名]@3.9.1 --save-dev //简写：-D 全局安装 npm install [包名] --global //简写：-g 卸载 npm uninstall [包名] 删除全局环境下的包： npm uninstall [包名] -g 查看全局插件命令： npm list -g --depth //简写：npm ls -g 查看模块版本 npm version //简写：npm -v 检查模块是否已经过时 npm outdated Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:35:10 "},"content/React/4-webpack.html":{"url":"content/React/4-webpack.html","title":"第四节：Webpack配置","keywords":"","body":" Webpack环境配置 创建并进入一个文件夹wepback: 初始化项目： 安装webpack： 检测是否安装成功： 安装代码分离包： css单独打包： 兼容css包： 监视文件更改包： 实时重载： 安装打包工具： 创建.babelrc并配置： 创建webpack.config.js并配置： 创建webpack.dev.config.js并配置 创建postcss.config.js并配置 Webpack环境配置 创建并进入一个文件夹wepback: mkdir webpack && cd webpack 初始化项目： npm init这会提示你关于项目的更多细节，并创建一个 package.json 文件。 使用 -y 标记表示你能接受 package.json 文件的一堆： npm init -y 安装webpack： npm install webpack --save-dev 检测是否安装成功： ./node_modules/.bin/webpack --help 安装代码分离包： npm install --save-dev css-loader style-loader css单独打包： npm install --save-dev extract-text-webpack-plugin 兼容css包： npm install autoprefixer --save-dev 监视文件更改包： webpack --progress --watch 实时重载： npm install --save-dev webpack-dev-server 安装打包工具： npm install --save lodash 创建.babelrc并配置： //自动加载的配置文件 { \"presets\": [\"env\",\"react\"] //presets（需要启动什么样的预设转码）：react //env：可以对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作 } 创建webpack.config.js并配置： const path = require('path'); const webpack = require('webpack'); const ExtractTextPlugin = require(\"extract-text-webpack-plugin\"); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, \"build\"), filename: \"bundle.[hash:5].js\", publicPath: 'build/' }, // watch: true, // devtool: \"source-map\", module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: \"babel-loader\" }, { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: \"postcss-loader\" }) }, { test: /\\.less$/, use: ExtractTextPlugin.extract({ fallback: \"style-loader\", use: [\"postcss-loader\", 'less-loader'] }) }, { test: /\\.(jpe?g|png)$/, use: 'file-loader' }, { test: require.resolve('jquery'), use: [{ loader: 'expose-loader', options: '$' }] } ] }, plugins: [ new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false, drop_console: false } }), new webpack.DefinePlugin({ 'process.env.NODE_ENV': '\"production\"' }), new ExtractTextPlugin(\"styles.css\"), new HtmlWebpackPlugin({ template: 'templete/index.html', filename: path.resolve(__dirname,'index.html'), minify: { collapseWhitespace: true } }) ] } 创建webpack.dev.config.js并配置 const path = require('path'); const webpack = require('webpack'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const OpenBrowserPlugin = require('open-browser-webpack-plugin'); module.exports = { entry: './src/index.js', output: { // path: path.resolve(__dirname, \"build\"), filename: \"bundle.[hash:5].js\", publicPath: '/' }, devServer: { // contentBase: path.join(__dirname, \"public\"), compress: true, port: 3000, historyApiFallback: true, hot: true }, devtool: \"source-map\", module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: \"babel-loader\" }, { test: /\\.css$/, use: ['style-loader', 'postcss-loader'] }, { test: /\\.less$/, use: ['style-loader', 'postcss-loader', 'less-loader'] }, { test: /\\.(jpe?g|png)$/, use: 'file-loader' }, { test: require.resolve('jquery'), use: [{ loader: 'expose-loader', options: '$' }] } ] }, plugins: [ new HtmlWebpackPlugin({ template: 'templete/index.html' }), new webpack.HotModuleReplacementPlugin(), new OpenBrowserPlugin({ url: 'http://localhost:3000' }) ] } 创建postcss.config.js并配置 module.exports = { //模块出口： plugins: [ //插件：兼容css，less编译成css require('autoprefixer'), require('cssnano') ] } Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:35:11 "},"content/React/5-hello-react.html":{"url":"content/React/5-hello-react.html","title":"第五节：Hello React","keywords":"","body":" Hello React 初始化一个项目react-hello 启动项目 退出项目 修改项目 Hello React 初始化一个项目react-hello create-react-app react-hello 注意：不要出现项目套项目，仓库套仓库。项目名称不要取包名（react...）。 启动项目 npm start 成功启动说明项目成功初始化 退出项目 ctrl + C 修改项目 删除src文件夹重新创建一个src rm -rf src && mkdir src 在src下新建一个index.js并返回项目文件夹 cd src && touch index.js && cd .. 注意：命令行下的位置 小贴士：console.dir() 详细信息 在index.js中写入下面代码 import React from 'react' import ReactDOM from 'react-dom' ReactDOM.render(Hello React,document.getElementById('root')) Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:20:54 "},"content/React/6-JSX.html":{"url":"content/React/6-JSX.html","title":"第六节：JSX语法","keywords":"","body":" JSX语法 jsx 简介 嵌入变量 JSX语法 jsx 简介 JSX就是 React.js 描述页面 UI 的方式（JSX 其实就是 JavaScript 对象） JSX语法需要bable进行编译，React.createElement() import React from 'react' import ReactDOM from 'react-dom' const element = Hello world; ReactDOM.render(element,document.querySelector('#root')) JSX为我们提供了创建react元素方法（React.createElement(component, props, ...children)）的语法糖（syntactic sugar）。上面的代码实质上等价于： import React from 'react' import ReactDOM from 'react-dom' var element = React.createElement( \"h1\", null, \"Hello, world!\" ) ReactDOM.render(element,document.getElementById('root')) 每个 DOM 元素的结构都可以用 JavaScript 的对象来表示。你会发现一个 DOM 元素包含的信息其实只有三个：标签名，属性，子元素。 React 所以 HTML的所有的信息我们都可以用合法的 JavaScript 对象来表示的。 React.createElement( \"div\", null, React.createElement( \"h1\", { className: 'title' }, \"React\" ) ) 嵌入变量 用大括号包裹 let name = 'Liu' let element = 大括号内可以写入变量，数字，求值表达式... let name = 'LiuEnQing' let male = true let obj = { age:24, tal:13947368104 } let ele = {name} {obj.age} {male ? '男' : '女'} 注释 {/*[需要注释内容]*/} Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:22:59 "},"content/React/7-render.html":{"url":"content/React/7-render.html","title":"第七节：组件的Render方法","keywords":"","body":" 创建模块组件 创建一个组件 创建模块组件 import React,{Component} from 'react'; import ReactDOM from 'react-dom'; 我们在文件头部从 react 的包当中引入了 React ，和 React.js 的组件父类 Component 只要你要写React.js组件，那么就必须要引入这两个东西。 react-dom可以帮助我们把这个用来描述 UI 信息的 JavaScript 对象（React 组件）变成 DOM 元素，并且渲染到页面上去。 所以可以总结一下从 JSX 到页面到底经过了什么样的过程 创建一个组件 import React from 'react' import ReactDOM from 'react-dom' ReactDOM.render(,document.querySelector('#root')) //querySelector()：JS原生选择器,类似jq中的$()选择器,功能强大; ReactDOM.render功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的元素上。 总结： JSX语法需要bable进行编译，转为这个方法React.createElement() 标签区分大小写 标签必须闭合 相邻的JSX元素必须包裹在一个闭合标签内 class写为className,for写为htmlfor 使用驼峰命名 声明式渲染：可以嵌入变量，变量用 {} 包裹 在JSX语法中可以嵌入变量和表达式,可以写js语法,但不能用js语句 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:24:36 "},"content/React/8-component.html":{"url":"content/React/8-component.html","title":"第八节：组件的组合、嵌套和组件树","keywords":"","body":" 组件的组合、嵌套和组件树 组建的创建 第一种组件的创建方式 function 第二种组件的创建方式 ES6类 组件内参数的传递 导入CSS 导入图片 组件的嵌套 子组件 父组件 组件树 组件的组合、嵌套和组件树 组建的创建 第一种组件的创建方式 function import React from 'react' import ReactDom from 'react-dom' function Hello(){ return ( 我是第一种组件的创建方式 ) } ReactDom.render(,document.querySelector('#root')) 注意： 自定义的组件都必须要用大写字母开头，普通的 HTML 标签都用小写字母开头。 必须有返回值,而且返回值必须是JSX elements 第二种组件的创建方式 ES6类 import React from 'react' class App extends React.Component{ render(){ return ( App ) } } export default App 组件内参数的传递 import React from 'react' import ReactDom from 'react-dom' function Word(props){ return ( My name is {props.name} ) } function Hello(){ return ( ) } ReactDom.render(,document.querySelector('#root')) 导入CSS //插入css外部样式： import './App.css' //行内样式 我是H1 //行内样式的时候，样式写成对象的模式，对象是js语言所以用大括号包裹 //1.{ backgroundColor:'teal', fontSize:'20px' } //2.写成一个方法，返回一个对象 //3.声明一个对象 //4.只要样式写为对象的方式 styles(){ return({ box:{ background:'green' }; }) } 我是H1 let styles={ h1:{ color:'#CCC', backgroundColor:'teal' }, div:{ width:'100vw', height:'200px' } } 我也是H1 导入图片 当作变量导入 //先导入： import img from './xxx.jpg' //引用本地： \"\" //网上图片直接引用： \"\" 组件的嵌套 子组件 import React from 'react' import Header from './Header' import Main from './Main' import Footer from './Footer' class App extends React.Component{ render(){ return( ) } } export default App 父组件 import React from 'react' import ReactDom from 'react-dom' import App from './App' ReactDom.render(,document.querySelector('#root')) 组件树 import React from 'react'; import ReactDOM from 'react-dom'; class Title extends React.Component { render(){ return ( React ) } } class Header extends Component { render () { return ( This is Header ) } } class Main extends Component { render () { return ( This is main content ) } } class Footer extends Component { render () { return ( This is footer ) } } class Index extends Component { render () { return ( ) } } ReactDOM.render(,document.getElementById('root')) 组件可以和组件组合在一起，组件内部可以使用别的组件。就像普通的 HTML 标签一样使用就可以。这样的组合嵌套，最后构成一个所谓的组件树。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:26:47 "},"content/React/9-onclick.html":{"url":"content/React/9-onclick.html","title":"第九节：事件监听","keywords":"","body":" 事件监听 例子 事件监听 当你需要为某个元素监听某个事件的时候，只需要简单地给它加上on*就可以了。而且你不需要考虑不同浏览器兼容性的问题 例子 React.js 会给每个事件监听传入一个event对象，这个对象提供的功能和浏览器提供的功能一致，而且它是兼容所有浏览器的。 例如我们现在要给button加上点击的事件监听： class App extends React.Component{ handleClick(){ console.log('Click') } render(){ return( 点击 ) } } 只需要给 button 按钮加上 onClick 的事件，onClick 紧跟着是一个表达式插入，这个表达式返回一个 App 自己的一个实例方法。 当用户点击按钮的时候，React.js 就会调用这个方法，所以你在控制台就可以看到 Click 打印出来。 绑定的时候给事件监听函数传入一些参数: class App extends React.Component{ constructor(){ super() this.state = { data:0 }; } handleNum(num){ this.setState({ data:this.state.data + num }) } render(){ return( {this.state.data} ) } } 新的可控组件方法： import React from 'react' import ReactDOM from 'react-dom' class App extends React.Component{ constructor(){ super() this.handleClick = this.handleClick.bind(this) } handleClick(){ console.log(this) } render(){ return ( App click ) } } ReactDOM.render(,document.querySelect('#root')) 注意 事件用驼峰命名法 这些 on* 的事件监听只能用在普通的 HTML 的标签上，而不能用在组件标签上 事件监听函数会被自动传入一个 event 对象 bind会把实例方法绑定到当前实例上，然后我们再把绑定后的函数传给React.js的 onClick事件监听 可以在 bind 的时候给事件监听函数传入一些参数 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:35:06 "},"content/React/10-state.html":{"url":"content/React/10-state.html","title":"第十节：组件的State和setState","keywords":"","body":" State(状态值) 定义state值 setState(接受对象参数) 利用setState方法切换状态值 setState的应用 State(状态值) state 控制组件内部的状态，state改变，重新render()界面重新渲染 定义state值 import React from 'react' class App extends React.Component{ constructor(){ super() //state属性等于一个对象 //对象内可以是一个数、数组、对象、布尔值等等，用,隔开 this.state = { num:0 } } render(){ return( {this.state.num} ) } } export default App setState(接受对象参数) 修改setState的方法可以触发render自动更新（界面重新渲染） 利用setState方法实现点击+1 import React from 'react' class App extends React.Component{ constructor(){ super() this.state = { num:0 } } handleClick(){ this.setState({ num: ++this.state.num }) } render(){ let styles={textAlign:'center'} return( {this.state.num} ) } } export default App 利用setState方法切换状态值 import React from 'react' class App extends React.Component{ constructor(){ super() this.state = { show:true } } handleClick(){ this.setState({ show:!this.state.show }) } render(){ return( {this.state.show ? '哈哈' : ''} ) } } export default App setState的应用 import React from 'react' class App extends React.Component{ constructor(){ super() this.handleClick = this.handleClick.bind(this) this.state = { num:0, show:false } } handleInc(num){ this.setState({ num: (this.state.num + num) {this.state.num} {this.state.show ? '出来混总是要还的' : '是你毁了一个我当好人的机会'} ) } } export default App Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:38:07 "},"content/React/12-props.html":{"url":"content/React/12-props.html","title":"第十一节：组件的props","keywords":"","body":" 配置组件的 props (属性) props 使用 props的children属性 function 也可以通过props传递 拓展应用 默认的props用 defaultProps 的属性设置 配置组件的 props (属性) 组件内部是通过 this.props 的方式获取到组件的参数的，如果this.props里面有需要的属性我们就采用相应的属性，没有的话就用默认的属性。 class App extends React.Component{ render(){ console.log(this.props) return ( App ) } } props 使用 在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为props对象的键值： import React from 'react' class Btn extends React.Component{ render(){ console.log(this.props) return ( ) } } class App extends React.Component{ render(){ console.log(this.props) return ( App ) } } export default App 数字也当作变量用 {} 包起来 import React from 'react' class Btn extends React.Component{ render(){ return ( age:{this.props.tal} ) } } class App extends React.Component{ render(){ return ( ) } } export default App props的children属性 import React from 'react' class Btn extends React.Component{ render(){ return ( {this.props.children} ) } } class App extends React.Component{ render(){ console.log(this.props) return ( App span标签 ) } } export default App 注意children的类型会根据标签里的内容改变 function 也可以通过props传递 通过ref获取子组件节点，通过props传递过去的方法修改state达成改变父组件状态 import React from 'react' class Test extends React.Component{ constructor(){ super() this.state = { show:true } } handleShow(){ this.setState({ show:!this.state.show }) } render(){ return( 杀人诛心 ) } } class Ref extends React.Component{ handleClick(){ this.test.handleShow() } render(){ return( this.test = test} onClick={this.handleClick.bind(this)}/> ) } } export default Ref 拓展应用 class Btn extends React.Component{ render(){ let styles = { height:'25px', padding:'0 20px', lineHeight:'25px', color:this.props.color, background:this.props.bg, border:'0' } return ( age:{this.props.tal} ) } } Btn.defaultProps = { bg:'blue', color :'white', name:'点击', tal:20 } 默认的props用 defaultProps 的属性设置 class Btn extends React.Component{ render(){ return ( age:{this.props.tal} ) } } Btn.defaultProps = { name:'点击', tal:20 } Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:40:51 "},"content/React/13-prop-types.html":{"url":"content/React/13-prop-types.html","title":"第十三节：数据类型的检测","keywords":"","body":" 数据类型检测 装包： 引用 数据类型检测 prop-types 包（React组件属性类型校验） 装包： npm i prop-types --save 引用 import PropTypes from 'prop-types' //利用包的PropTypes.number检测tal是否为数字 Btn.propTypes = { tal:PropTypes.number } Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:43:34 "},"content/React/14-Card.html":{"url":"content/React/14-Card.html","title":"第十四节：案例（Card）","keywords":"","body":" 小案例（card） 可复用子组件 小案例（card） import React from 'react' import './App.css' import Card from './Card' class App extends React.Component{ render(){ console.log(this.props) return ( More} > 每个人心中都有一团火， 路过的人只看到烟。 ——文森特·梵高 ) } } export default App 可复用子组件 import React from 'react' import PropTypes from 'prop-types' class Card extends React.Component{ render(){ return ( {this.props.title} {this.props.more} {this.props.children} ) } } Card.defaultProps = { title:'请输入标题', more:More, children:'请传入内容' } Card.propTypes = { title:PropTypes.string, more:PropTypes.element, children:PropTypes.oneOfType([ PropTypes.object, PropTypes.array, ]) } export default Card Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:45:49 "},"content/React/15-dom.html":{"url":"content/React/15-dom.html","title":"第十五节：React中获取DOM节点","keywords":"","body":" React获取DOM节点 原生方法 Jquery方法 通过React的ref来获取DOM节点 获取子组件的节点 React获取DOM节点 原生方法 利用原生方法中抓取DOM节点的方法，例如getElementById，querySelector等 import React from 'react' class RefDemo extends React.Component{ handleClick(){ document.getElementsByTagName('p')[0].style.color = 'red' } render(){ return( 哈哈哈 ) } } export default RefDemo Jquery方法 安装jquery包，使用jq选择器抓取DOM节点，可以用jq方法进行操作 import React from 'react' import $ from 'jquery' class RefDemo extends React.Component{ handleClick(){ $('p').toggle('slow') //有就隐藏，没有就显示 } render(){ return( 哈哈哈 ) } } export default RefDemo 通过React的ref来获取DOM节点 import React from 'react' class Ref extends React.Component{ constructor(){ super() this.state = { title:'' } } handleClick(){ this.setState({ title:this.value.value }) } render(){ return( 123{this.state.title} this.value = value } onChange={this.handleClick.bind(this)} /> ) } } export default Ref 获取子组件的节点 import React from 'react' class Test extends React.Component{ constructor(){ super() this.state = { show:true } } handleShow(){ this.setState({ show:!this.state.show }) } render(){ return( 杀人诛心 ) } } class Ref extends React.Component{ handleClick(){ this.test.handleShow() } render(){ return( this.test = test} onClick={this.handleClick.bind(this)}/> ) } } export default Ref Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:47:59 "},"content/React/16-lifecycle.html":{"url":"content/React/16-lifecycle.html","title":"第十六节：生命周期函数","keywords":"","body":" 生命周期函数 首次加载时触发的生命周期 更新阶段（重新渲染） 子组件的生命周期流程 子组件 父组件 销毁组件 子组件（要销毁的组件） 父组件 生命周期函数 首次加载时触发的生命周期 class App extends React.Component{ constructor(){ super() console.log('constructor') } componentWillMount(){ console.log('will Mount') } componentDidMount(){ console.log('did Mount') } render(){ console.log('render') return( App/div> ) } } export default App constructor（自带的默认方法传递state和props） 构造函数，只有初始化时调用载一次 comonentWillMount 挂载前 在组件挂载之前调用一次。如果在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次。 render 挂载（必须） 返回值必须是一个React的element（JSX节点），不能在render内修改state comonentDidMount 挂载完成后 在组件挂载之后调用一次。这个时候，子主键也都挂载好了，可以在这里使用refs。 更新阶段（重新渲染） state被setState修改或 props 被修改会触发更新 import React from 'react' class App extends React.Component{ constructor(){ console.log('constructor') super() this.state=({ num:0 }) } componentWillMount(){ console.log('will Mount') } componentDidMount(){ console.log('did Mount') } shouldComponentUpdate(nextProps,nextState){ console.log('should Update',nextProps,nextState) return true } componentWillUpdate(){ console.log('will Update') } componentDidUpdate(){ console.log('did Update') } render(){ console.log('render') return( {this.state.num} this.setState({num:++this.state.num})}>+1 ) } } export default App shouldComponentUpdate （判断是否需要重新渲染组件） 必须有返回值（返回值为一个bool值）如果返回true重新render（渲染）。 shouleComponentUpdata(nextProps,nextState)的两个参数（形参） componentWillUpdate （重新渲染前） shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。 除了首次render之后调用componentWillMount，其它render结束之后都是调用componentWillUpdate。 render（渲染） componentDidUpdate（渲染完成后） 除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。 子组件的生命周期流程 子组件 import React from 'react' class Test extends React.Component{ constructor(){ super() console.log('test constructor') } componentWillMount(){ console.log('test will Mount') } componentDidMount(){ console.log('test did Mount') } shouldComponentUpdate(nextProps,nextState){ console.log('test should') return true } componentWillUpdate(){ console.log('test Update') } componentDidUpdate(){ console.log('test did Update') } render(){ console.log('text render') return ( {this.props.num} ) } } export default Test 父组件 import React from 'react' import Test from './Test' class App extends React.Component{ constructor(){ console.log('constructor') super() this.state = ({ num:0 }) } componentWillMount(){ console.log('will Mount') } componentDidMount(){ console.log('did Mount') } componentWillReceiveProps(nextProps){ console.log('ReceiveProps',nextProps) } shouldComponentUpdate(nextProps,nextState){ console.log('should',nextProps,nextState.num) if(nextState.num>10){ alert('超过上限') this.btn.disabled = true }else{ return true } } componentWillUpdate(){ console.log('Update') } componentDidUpdate(){ console.log('did Update') } render(){ console.log('render') return( this.btn = btn} onClick={() => this.setState({num:++this.state.num})} /> ) } } export default App componentWillReceiveProps（props改变时触发） props是父组件传递给子组件的。父组件发生render的时候子组件就会调用componentWillReceiveProps（不管props有没有更新，也不管父子组件之间有没有数据交换）。 销毁组件 子组件（要销毁的组件） import React from 'react' class Test extends React.Component{ constructor(){ super() console.log('test constructor') } componentWillMount(){ console.log('test will Mount') } componentDidMount(){ console.log('test did Mount') } shouldComponentUpdate(nextProps,nextState){ console.log('test should') return true } componentWillUpdate(){ console.log('test Update') } componentDidUpdate(){ console.log('test did Update') } componentWillUnmount(){ console.log('test Un') } render(){ console.log('text render') return ( {this.props.num} ) } } export default Test 父组件 import React from 'react' import Test from './Test' class App extends React.Component{ constructor(){ console.log('constructor') super() this.state = ({ num:0, show:true }) } componentWillMount(){ console.log('will Mount') } componentDidMount(){ console.log('did Mount') } componentWillReceiveProps(nextProps){ console.log('ReceiveProps',nextProps) } shouldComponentUpdate(nextProps,nextState){ console.log('should',nextProps,nextState.num) if(nextState.num>10){ alert('超过上限') this.btn.disabled = true }else{ return true } } componentWillUpdate(){ console.log('Update') } componentDidUpdate(){ console.log('did Update') } render(){ console.log('render') return( { this.state.show ? : null } this.btn = btn} onClick={() => this.setState({num:++this.state.num})} /> this.setState({show:false})} /> ) } } export default App componentWillUnmount （销毁组件） 组件被卸载的时候调用。一般在componentDidMount里面注册的事件需要在这里删除。很少应用 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:54:36 "},"content/React/17-Context.html":{"url":"content/React/17-Context.html","title":"第十七节：Context","keywords":"","body":" Context 使用 Context 的原因 例 Context context是在 react @ 0.14 版本以后发布的一个高级且实验性的功能，有可能在未来做出更改。不推荐使用! 使用 Context 的原因 实现 越级 传递props 例 祖父组件 import React, { Component } from 'react' import propTypes from 'prop-types' import Father from './Father' class GrandFather extends Component { getChildContext(){ return { hello:\"son\" } } render(){ return ( GrandFather ) } } GrandFather.childContextTypes = { hello:propTypes.string } export default GrandFather 父组件 import React, { Component } from 'react' import Son from './Son' class Father extends Component { render() { return ( Father ) } } export default Father 子组件 import React, { Component } from 'react' import propTypes from 'prop-types' class Son extends Component { render() { console.log(this.context) return ( Son {this.context.hello} ) } } Son.contextTypes = { hello:propTypes.string } export default Son Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-10 18:55:37 "},"content/Js/RegExp.html":{"url":"content/Js/RegExp.html","title":"第一节：RegExp","keywords":"","body":" 正则表达式 创建一个正则表达式 正则表达式直接量语法 调用RegExp对象的构造函数语法 正确编写正则表达式 两种创建表达式都可遵循同一个标准: 正则表达式中的特殊字符及修饰 方括号 元字符 量词 修饰符 RegExp 自带方法 正则表达式 正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。 创建一个正则表达式 两种方法，一种是直接写，由包含在斜杠之间的模式组成；另一种是调用RegExp对象的构造函数。 正则表达式直接量语法 如下所示： /* /pattern/flags */ const regex = /ab+c/; //匹配a后面紧跟着多个b，在紧跟着c的字符串 const regex = /^[a-zA-Z]+[0-9]*\\W?_$/gi; 优点： 在加载脚本后，正则表达式字面值提供正则表达式的编译。当正则表达式保持不变时，使用此方法可获得更好的性能。 调用RegExp对象的构造函数语法 如下所示： /* new RegExp(pattern [, flags]) */ let regex = new RegExp(\"ab+c\"); let regex = new RegExp(/^[a-zA-Z]+[0-9]*\\W?_$/, \"gi\"); let regex = new RegExp(\"^[a-zA-Z]+[0-9]*\\W?_$\", \"gi\"); 优点： 使用构造函数，当你知道正则表达式模式将会改变，或者你不知道模式，并从另一个来源，如用户输入。 正确编写正则表达式 一个正则表达式模式是由简单的字符所构成的，比如/abc/, 或者是简单和特殊字符的组合，比如 /abc/ 或 /Chapter (\\d+).\\d/。后者用到了括号，它在正则表达式中可以被用作是一个记忆设备。这一部分正则所匹配的字符将会被记住，在后面可以被利用。 两种创建表达式都可遵循同一个标准: 只不过直接量语法使用： /要匹配的规则/接修饰符 构造函数语法使用：new RegExp(要匹配的规则, \"修饰符\") 注意 构造函数语法比较随性：匹配规则可以当字符串，也可用/ pattern /双反斜杠包裹，最主要可以嵌入变量，匹配一个可以变的正则。 正则表达式中的特殊字符及修饰 方括号 方括号用于查找某个范围内的字符： 元字符 元字符（Metacharacter）是拥有特殊含义的字符： 量词 匹配包含的数量： 修饰符 RegExp 自带方法 1. exec() 检索字符串中指定的值。返回找到的值，并确定其位置。 var str = \"hello regexp\"; var patt = new RegExp(\"regexp\",\"g\"); patt.exec(str) //返回值：[\"regexp\", index: 6, input: \"hello regexp\"] 返回值 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 var str = \"hello regexp\"; var patt = new RegExp(\"hehe\",\"g\"); patt.exec(str) //返回值：null 2. test() 方法用于检测一个字符串是否匹配某个模式. var str = \"hello regexp\"; var patt = new RegExp(\"regexp\",\"g\"); patt.test(str) //返回值：true 返回值 如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。 var str = \"hello regexp\"; var patt = new RegExp(\"hehe\",\"g\"); patt.test(str) //返回值：false 注意 支持正则表达式的 String 对象的方法放在字符串里说。 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-16 15:28:25 "},"content/Js/string.html":{"url":"content/Js/string.html","title":"第二节：String","keywords":"","body":"string 字符串 String 全局对象是一个用于字符串或一个字符序列的构造函数。 语法 let str=\"string text\" let str1=\"中文/汉语\" let str2=new String(str) //返回值：{0: \"s\", 1: \"t\", 2: \"r\", 3: \"i\", 4: \"n\", 5: \"g\", 6: \" \", 7: \"t\", 8: \"e\", 9: \"x\", 10: \"t\", length: 11, [[PrimitiveValue]]: \"string text\"} 注意 通过new，它返回一个新创建的 String 对象，存放的是字符串 str2 或 str2 的字符串表示 当不用 new 时，它只把 str 转换成原始的字符串，指向这个string，并返回转换后的值。 还有从es6开始 可以用字符串模板书写 let str=`string text` let str1=`中文/汉语` 书写时可能碰到特别长的字符串 可以用字符串拼接书写 let longString = \"This is a very long string which needs \" + \"to wrap across multiple lines because \" + \"otherwise my code is unreadable.\"; 或者 使用 \\ 在每行末尾使用反斜杠字符 \\，以指示字符串将在下一行继续。确保反斜杠后面没有空格或任何除换行符之外的字符或缩进; 否则反斜杠将不会工作。 如下所示： let longString = \"This is a very long string which needs \\ to wrap across multiple lines because \\ otherwise my code is unreadable.\"; String 属性 String.prototype String.prototype 属性表示 String原型对象。可以使用 String.prototype.constructor 用于创造对象的原型对象的特定的函数。 String.length length属性表示返回字符串长度 let str ='wentoos' str.length// 返回值：7 String 方法 常用的： charAt() //返回在指定位置的字符。 concat() //连接字符串。 indexOf() //检索字符串。 lastIndexOf() //从后向前搜索字符串。 match() //找到一个或多个正则表达式的匹配。 replace() //替换与正则表达式匹配的子串。 search() //检索与正则表达式相匹配的值。 slice() //提取字符串的片断，并在新的字符串中返回被提取的部分。 small() //使用小字号来显示字符串。 split() //把字符串分割为字符串数组。 toString() //返回字符串。 sub() //把字符串显示为下标。 substr() //从起始索引号提取字符串中指定数目的字符。 substring() //提取字符串中两个指定的索引号之间的字符。 toLocaleLowerCase() //把字符串转换为小写。 toLocaleUpperCase() //把字符串转换为大写。 toLowerCase() //把字符串转换为小写。 toUpperCase() //把字符串转换为大写。 不常用的： toSource() //代表对象的源代码。 valueOf() //返回某个字符串对象的原始值。 anchor() //创建 HTML 锚。 big() //用大号字体显示字符串。 blink() //显示闪动字符串。 bold() //使用粗体显示字符串。 charCodeAt() //返回在指定的位置的字符的 Unicode 编码。 fixed() //以打字机文本显示字符串。 fontcolor() //使用指定的颜色来显示字符串。 fontsize() //使用指定的尺寸来显示字符串。 fromCharCode() //从字符编码创建一个字符串。 italics() //使用斜体显示字符串。 link() //将字符串显示为链接。 localeCompare() //用本地特定的顺序来比较两个字符串。 strike() //使用删除线来显示字符串。 详细介绍使用方法请到W3c Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-16 18:47:09 "},"content/Js/Array.html":{"url":"content/Js/Array.html","title":"第三节：Array","keywords":"","body":"Array 对象 啥是Array Array 对象用于在单个的变量中存储多个值。 let arr =[1,2,3] 创建 array 语法 let arr =['arr','acc'] let arr2=new Array('arr','acc') let arr2 = []; arr2[0] = 1; Array 属性 Array.prototype Array.prototype 属性表示 Array 构造函数的原型，并允许您向所有Array对象添加新的属性和方法。 Array.length length属性表示返回Array长度 let str =[1,2,3] str.length//返回值：3 Array 方法 Array.concat() 合并数组并返回新的数组 var arr = [1,2,3]; var arr1 = [4,5,6]; var arr2 = arr1.concat(arr); console.log(arr2) console.log(arr) console.log(arr1) Array.reverse() 颠倒数组并返回新的数组（原数组已经改变） var arr = [1,2,3,4,5]; var arr1 = arr.reverse(); console.log(arr); console.log(arr1); 判断一个数是否为回文数： //例如：123321 let num ='123321'; let arr =num.split('') let arr1 =arr.reverse() console.log(arr===arr1); Array.pop() 删除并返回数组的最后一个元素 var arr = [1,2,3,4,6]; var num = arr.pop(); console.log(arr); //[1,2,3,4] console.log(num); //6 Array.shift() 删除并返回数组的第一个元素 var arr = [1,2,3,4,6]; var num1 = arr.shift(); console.log(arr); //[2,3,4,6] console.log(num1); //1 Array.push() 向数组最后面添加一个或多个元素返回新数组的长度 var arr = [1,2,3,4,6]; var num2 = arr.push(6,6) console.log(arr); //[1,2,3,4,6,6,6] console.log(num2);] // 7 push(a,b,c) abc 要添加的元素，必有一个 Array.unshift() 向数组最前面添加一个或多个元素返回新数组的长度 var arr = [1,2,3,4,6]; var num3 = arr.unshift(1); console.log(arr) //[1,1,2,3,4,6] console.log(num3) //6 Array.splice(a,b,c) a 代表删除或者添加的位置（数组的下标） b 删除的个数 c 代表添加的内容 添加或删除元素并返回删除的数组 var arr = [1,2,3,4,6]; var num4 = arr.splice(2,2,56) console.log(arr) //[1,2,56,6] console.log(num4) //[3,4] Array.slice(a,b) 截取数组 a-b(数组下标) 包括a 不包括 b 并返回被截取数组 var arr = [1,2,3,4,6]; var num5 = arr.slice(1,2); console.log(arr) //[1,2,3,4,6] console.log(num5) //[1,2,3] Array.sort() 数组排序 var newArr = [2,3,1,2,4,33,22,11,55,22]; var newStr = [\"eee\",\"sjhgk\",\"uytjl\",\"a\",\"c\",\"b\"]; newArr.sort(); console.log(newArr); newStr.sort(); console.log(newStr) var c = function(a,b){return b-a}; newArr.sort(c); console.log(newArr); 使用sort排序时，如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。如达到按照值的大小排列时，必须给sort方法传一个函数，这样才能真正的排序： var c = function(a,b){return b-a} || var c = function(a,b){return a-b} 参数a,b： b-a 倒序 a-b 正序 Array.join(a) 把数组转化为字符串 a:链接数组每一项的字符串 var newArr = [2,3,1,2,4,33,22,11,55,22]; var str = newArr.join(\"+\"); console.log(newArr); // [2, 3, 1, 2, 4, 33, 22, 11, 55, 22] console.log(str); // 2+3+1+2+4+33+22+11+55+22 Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-19 10:22:45 "},"content/Js/array-bianli.html":{"url":"content/Js/array-bianli.html","title":"第四节：Array遍历","keywords":"","body":"数组遍历 排序 sort 快速排序 var newArr = [2,3,1,2,4,33,22,11,55,22]; var newStr = [\"eee\",\"sjhgk\",\"uytjl\",\"a\",\"c\",\"b\"]; newArr.sort(); console.log(newArr); newStr.sort(); console.log(newStr) var c = function(a,b){return b-a}; newArr.sort(c); console.log(newArr); 使用sort排序时，如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。如达到按照值的大小排列时，必须给sort方法传一个函数，这样才能真正的排序： var c = function(a,b){return b-a} || var c = function(a,b){return a-b} 冒泡排序 var newArr = [2,3,1,2,4,33,22,11,55,22]; for(var j = 0;jarr[i+1]){ var da = arr[i]; arr[i] = arr[i+1]; arr[i+1] = da; } } } 利用for循环将值传递赋值进行排序 数组去重 直接去重 var arr = [1,3,22,3,3,3]; for(var i = 0;i 排序后去重 for(var j = 0;jarr[i+1]){ var da = arr[i]; arr[i] = arr[i+1]; arr[i+1] = da; } } } console.log(arr) for(var j = arr.length;j>=0;j--){ if(arr[j] == arr[j-1]){ console.log(j) arr.splice(j,1); } } Copyright © wentoos.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-19 15:11:36 "}}